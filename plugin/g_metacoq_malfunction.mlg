(*i camlp4deps: "grammar/grammar.cma" i*)

DECLARE PLUGIN "coq-metacoq-malfunction.plugin"

{

open Names
open Pp
open Ltac_plugin
open Stdarg
open Pcoq.Prim
open Tacexpr
open Tacinterp
open Stdarg
open Tacarg
open Genredexpr

open Metacoq_malfunction

}


VERNAC ARGUMENT EXTEND metaCoqRegister_extract_cnst 
| [ reference(gr) "=>" string(str) ] -> { (extract_constant (Option.get (Constrintern.locate_reference gr)) str) }
END

VERNAC COMMAND EXTEND MetaCoqExtract_Register CLASSIFIED AS SIDEFF
| [ "MetaCoq" "Register" "Extraction" "[" metaCoqRegister_extract_cnst_list_sep(prims, ",") "]" "Packages" "[" string_list_sep(packages, ",") "]" ] -> {
    register prims packages
  }
END


ARGUMENT EXTEND extract_args
| [ "-unsafe" ] -> { Unsafe }
| [ "-time" ] -> { Time }
| [ "-typed" ] -> { Typed }
| [ "-bypass-qeds" ] -> { BypassQeds }
| [ "-fast" ] -> { Fast }
END

VERNAC COMMAND EXTEND MetaCoqExtract CLASSIFIED AS QUERY
| [ "MetaCoq" "Extraction" "-help" ] -> {
  let usage = "MetaCoq (Bypass)? Extraction [term] [output_file]?" in
  Feedback.msg_notice (str usage)
  }
| [ "MetaCoq" "Extraction" extract_args_list(l) constr(c) string_opt(dest) ] -> {
    let env = Global.env () in
    let evm = Evd.from_env env in
    let (c, _) = Constrintern.interp_constr env evm c in
    Metacoq_malfunction.extract l env evm c dest
  }
END
