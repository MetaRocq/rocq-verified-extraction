(*i camlp4deps: "grammar/grammar.cma" i*)

DECLARE PLUGIN "coq-metacoq-extraction-malfunction.plugin"

{

open Stdarg
open Pp
open PeanoNat.Nat
open Datatypes
open Vernacextend
open Tm_util

open Coq_metacoq_extraction_plugin.Metacoq_malfunction
open Coq_metacoq_extraction_plugin.G_metacoq_malfunction

let pr_char c = str (Char.escaped c)

let bytes_of_list l =
  let bytes = Bytes.create (List.length l) in
  let rec fill acc = function
    | [] -> bytes
    | c :: cs ->
      Bytes.set bytes acc c;
      fill (1 + acc) cs
  in fill 0 l

let pr_char_list l =
  (* We allow utf8 encoding *)
  str (Caml_bytestring.caml_string_of_bytestring l)

(** The ML value representation of an erased quoted program does not directly match 
  the one expected by CertiCoq erase function as singleton inductive types are unboxed, 
  we use Obj.t surgery to transform the value. 
  
  This involves the transformation of universes sets, constraints sets and the representation
  of universe values.
  *)

module FixProgram = struct
  open Universes0
  open BasicAst
  open Ast0

  let fix_set u =
    (* The representation of a proof object *)
    let proof_obj = Obj.magic 1 in
    let block = Obj.new_block 0 2 in
    Obj.set_field block 0 (Obj.magic u);
    Obj.set_field block 1 proof_obj;
    block

  let fix_universe u =
    let open Universe in
    let open Universes0.Sort in
    let proof_obj = Obj.magic 1 in
    let fix_ues ues : Obj.t = 
      let block = Obj.new_block 0 2 in
      Obj.set_field block 0 (Obj.magic ues);
      Obj.set_field block 1 proof_obj;
      block
    in
    let fix_neues neues : Obj.t = 
      let ues = fix_ues neues in
      let block = Obj.new_block 0 2 in
      Obj.set_field block 0 ues;
      Obj.set_field block 1 proof_obj;
      block
    in
    match u with 
    | Coq_sProp -> Coq_sProp
    | Coq_sSProp -> Coq_sSProp
    | Coq_sType neues -> Coq_sType (Obj.magic (fix_neues neues))

  let fix_term (p : Ast0.term) : Ast0.term =
    let open List in
    let rec aux p = 
    match p with
    | Coq_tRel _ | Coq_tVar _ | Coq_tInd _ | Coq_tConst _ | Coq_tConstruct _ -> p
    | Coq_tEvar (k, l) -> Coq_tEvar (k, map aux l)
    | Coq_tSort u -> Coq_tSort (fix_universe u)
    | Coq_tCast (t, k, t') -> Coq_tCast (aux t, k, aux t')
    | Coq_tProd (na, t, t') -> Coq_tProd (na, aux t, aux t')
    | Coq_tLambda (na, t, t') -> Coq_tLambda (na, aux t, aux t')
    | Coq_tLetIn (na, t, b, t') -> Coq_tLetIn (na, aux t, aux b, aux t')
    | Coq_tApp (t, l) -> Coq_tApp (aux t, map aux l)
    | Coq_tCase (ci, p, c, brs) -> Coq_tCase (ci, aux_pred p, aux c, map aux_branch brs)
    | Coq_tProj (p, t) -> Coq_tProj (p, aux t)
    | Coq_tFix (mfix, i) -> Coq_tFix (map aux_def mfix, i)
    | Coq_tCoFix (mfix, i) -> Coq_tCoFix (map aux_def mfix, i)
    | Coq_tInt i -> Coq_tInt i
    | Coq_tFloat f -> Coq_tFloat f
    | Coq_tArray (u, v, def, ty) -> Coq_tArray (u, map aux v, aux def, aux ty)
    and aux_pred { puinst = puinst; pparams = pparams; pcontext = pcontext; preturn = preturn } =
      { puinst; pparams = map aux pparams; pcontext; preturn = aux preturn }
    and aux_branch { bcontext = bcontext; bbody = bbody } =
      { bcontext; bbody = aux bbody }
    and aux_def { dname = dname; dtype = dtype; dbody = dbody; rarg = rarg } =
      { dname; dtype = aux dtype; dbody = aux dbody; rarg }
    in aux p

  let option_map f (x : 'a option) = 
    match x with
    | None -> None
    | Some x -> Some (f x)

  let fix_rel_context ctx =
    let open BasicAst in 
    let fix_decl {decl_name; decl_body; decl_type} =
      {decl_name; decl_body = option_map fix_term (Obj.magic decl_body); decl_type = fix_term decl_type}
    in
    List.map fix_decl ctx
    
  let fix_universes_decl = function
    | Monomorphic_ctx -> Monomorphic_ctx
    | Polymorphic_ctx (names, set) -> Polymorphic_ctx (names, Obj.magic (fix_set set))
    
  let fix_universes (levels, cstrs) = 
    (Obj.magic (fix_set levels), Obj.magic (fix_set cstrs))

  let fix_declarations decls = 
    let open Ast0.Env in
    let fix_constructor {cstr_name; cstr_args; cstr_indices; cstr_type; cstr_arity} = 
      {cstr_name; cstr_args = fix_rel_context cstr_args; 
      cstr_indices = List.map fix_term cstr_indices; 
      cstr_type = fix_term cstr_type; 
      cstr_arity}
    in
    let fix_projection {proj_name; proj_relevance; proj_type} =
      { proj_name; proj_relevance; proj_type = fix_term proj_type }
    in  
    let fix_ind_body {ind_name; ind_indices; ind_sort; ind_type; ind_kelim; ind_ctors; ind_projs; ind_relevance} =
      {ind_name; ind_indices = fix_rel_context ind_indices; ind_sort = fix_universe ind_sort;
      ind_type = fix_term ind_type; ind_kelim; 
      ind_ctors = List.map fix_constructor ind_ctors; 
      ind_projs = List.map fix_projection ind_projs; 
      ind_relevance}
    in
    let fix_decl (kn, decl) =
      let decl' = match decl with
      | Ast0.Env.ConstantDecl {cst_type; cst_body; cst_universes; cst_relevance} ->
        Ast0.Env.ConstantDecl { cst_type = fix_term cst_type; cst_body = option_map fix_term (Obj.magic cst_body);
        cst_universes = fix_universes_decl cst_universes; cst_relevance }
      | Ast0.Env.InductiveDecl { ind_finite; ind_npars; ind_params; ind_bodies; ind_universes; ind_variance} ->
        Ast0.Env.InductiveDecl { ind_finite; ind_npars; ind_params = fix_rel_context ind_params; 
        ind_bodies = List.map fix_ind_body ind_bodies; 
        ind_universes = fix_universes_decl ind_universes; 
        ind_variance}
      in (kn, decl')
    in
    List.map fix_decl decls

  let fix_quoted_program (p : Ast0.Env.program) = 
    let ({ Ast0.Env.universes = universes; declarations = declarations; retroknowledge = retro }, term) = p in
    let term = fix_term term in
    let universes = fix_universes universes in
    let declarations = fix_declarations declarations in
    { Ast0.Env.universes = universes; declarations; retroknowledge = retro }, term
end

module Caml_byte =
struct
  open Compile_malfunction

  (* Same representations in OCaml and Malfunction *)
  let char_of_byte (x : byte) : char = Obj.magic x
  let byte_of_char (x : char) : byte = Obj.magic x

end

module Caml_bytestring =
struct

  open Compile_malfunction
  open Caml_byte

  let rec caml_bytestring_length_aux s acc =
    match s with
    | EmptyString -> acc
    | String (_, s) -> caml_bytestring_length_aux s (acc + 1)

  let caml_bytestring_length s = caml_bytestring_length_aux s 0
    
  let caml_string_of_bytestring (l : t) : string =
    let len = caml_bytestring_length l in
    let buf = Bytes.create len in
    let rec aux i = function
      | EmptyString -> ()
      | String (c, cs) ->
        Bytes.set buf i (Caml_byte.char_of_byte c); aux (i + 1) cs
    in
    aux 0 l;
    Bytes.to_string buf

  let bytestring_of_caml_string (s : string) : t =
    let rec aux acc i =
      if i < 0 then acc
      else aux (String (byte_of_char s.[i], acc)) (i - 1)
    in aux EmptyString (String.length s - 1)
end

module Caml_bool =
struct
  open Compile_malfunction

  let of_coq = function
    | True -> true
    | False -> false

  let to_coq x = 
    if x then True else False
end

module Caml_nat =
struct
  open Compile_malfunction
  let nat_of_caml_int i =
    let rec aux acc i =
      if i < 0 then acc
      else aux (S acc) (i - 1)
    in aux O (i - 1)

  let rec iter_nat f acc = function
    | O -> acc
    | S x -> iter_nat f (f acc) x

  let caml_int_of_nat n = iter_nat Stdlib.succ 0 n
end

let interp_prim = function
  | Global (module_, label) ->
    let module_ = Caml_bytestring.bytestring_of_caml_string module_ in
    let label = Caml_bytestring.bytestring_of_caml_string label in
    Compile_malfunction.Global (module_, label)
  | Erased -> Erased
  | Primitive (symb, arity) ->
    let symbol = Caml_bytestring.bytestring_of_caml_string symb in
    let arity = Caml_nat.nat_of_caml_int arity in
    Compile_malfunction.Primitive (symbol, arity)

let interp_prims prims = 
  (* Caution, we're using the string_of_kername of the pure ocaml extraction *)
  List.map (fun (kn, p) -> (Obj.magic (Kernames.string_of_kername kn), interp_prim p)) prims

let interp_pipeline_config c : Compile_malfunction.malfunction_pipeline_config = 
  let { erasure_config = erasure_config; prims = prims } = c in
  let { enable_cofix_to_fix = enable_cofix_to_fix; 
        enable_typed_erasure = enable_typed_erasure; 
        enable_fast_remove_params = enable_fast_remove_params } = erasure_config in
 
 (*       dearging_config = dearging_config  = erasure_config in
  let { do_trim_ind_masks = do_trim_ind_masks; 
        do_trim_const_masks = do_trim_const_masks;
        overridden_masks = overridden_masks } = dearging_config in *)
  let erasure_config = 
    Compile_malfunction.({ 
      enable_cofix_to_fix = Caml_bool.to_coq enable_cofix_to_fix; 
      enable_typed_erasure = Caml_bool.to_coq enable_typed_erasure; 
      enable_fast_remove_params = Caml_bool.to_coq enable_fast_remove_params;
      dearging_config = 
        { do_trim_ctor_masks = Compile_malfunction.False;
          do_trim_const_masks = Compile_malfunction.False  (*Caml_bool.to_coq do_trim_const_masks*);
          overridden_masks = (fun _ -> None) } } )
  in
  Compile_malfunction.({ erasure_config; prims = interp_prims prims })

let compile_malfunction conf p = 
  let conf = interp_pipeline_config conf in
  let p = FixProgram.fix_quoted_program p in
  Caml_bytestring.caml_string_of_bytestring (Compile_malfunction.compile_malfunction_gen conf p)

let extract = extract compile_malfunction

}

VERNAC COMMAND EXTEND MetaCoq_Verified_Extraction CLASSIFIED AS QUERY
| [ "MetaCoq" "Verified" "Extraction" "-help" ] -> {
  let usage = "MetaCoq (Bypass)? Extraction [term] [output_file]?" in
  Feedback.msg_notice (str usage)
  }
| [ "MetaCoq" "Verified" "Extraction" extract_args_list(l) constr(c) string_opt(dest) ] -> {
    let env = Global.env () in
    let evm = Evd.from_env env in
    let loc = Constrexpr_ops.constr_loc c in
    let (c, _) = Constrintern.interp_constr env evm c in
    extract ?loc l env evm c dest
  }
END
